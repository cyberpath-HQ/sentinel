---
title: Troubleshooting & FAQ
description: Common issues, solutions, and frequently asked questions about Sentinel, including WAL troubleshooting.
section: References
order: 51
keywords: ["troubleshooting", "faq", "problems", "solutions", "debugging", "wal"]
related: ["architecture", "examples", "api-reference", "wal"]
---

This guide helps you troubleshoot common issues and answers frequently asked questions about Sentinel.

## Common Issues

### Store Creation Fails

**Problem:** `Store::new()` returns an error.

**Causes:**

- Insufficient filesystem permissions
- Path contains invalid characters
- Disk full or read-only filesystem

**Solutions:**

```rust
// Check directory permissions
use std::fs;

match Store::new("./my_store", None).await {
    Ok(store) => println!("Store created"),
    Err(e) => {
        eprintln!("Error: {}", e);
        // Check if we can write to parent directory
        match fs::create_dir_all("./my_store") {
            Ok(_) => println!("Directory writable"),
            Err(e) => eprintln!("Permission error: {}", e),
        }
    }
}
```

### Document Insert Fails

**Problem:** `insert()` returns an error.

**Causes:**

- Invalid document ID (contains `/`, `\`, `..`, or starts with `.`)
- Invalid JSON in data
- Disk full
- Passphrase mismatch for signed stores

**Solutions:**

```rust
// Validate document ID
fn is_valid_id(id: &str) -> bool {
    !id.starts_with('.')
        && !id.contains('/')
        && !id.contains('\\')
        && id != ".."
        && id != "."
}

// Use before insert
if !is_valid_id("my-doc-id") {
    eprintln!("Invalid document ID");
}

// Validate JSON
match serde_json::to_value(&my_struct) {
    Ok(data) => {
        collection.insert("doc-1", data).await?;
    }
    Err(e) => {
        eprintln!("JSON serialization error: {}", e);
    }
}
```

### Query Returns No Results

**Problem:** Query executes but returns empty results.

**Causes:**

- Incorrect filter values
- Type mismatches (string vs number)
- Field doesn't exist in documents
- Case sensitivity

**Solutions:**

```rust
// Debug query results
let query = QueryBuilder::new()
    .filter("age", Operator::GreaterThan, json!(25))
    .build();

let result = users.query(query).await?;
println!("Execution time: {:?}", result.execution_time);

// Check if documents exist
let all_docs: Vec<_> = users.all().try_collect().await?;
println!("Total documents: {}", all_docs.len());

// Inspect document structure
if let Some(doc) = all_docs.first() {
    println!("Sample document: {}", serde_json::to_string_pretty(doc.data())?);
}

// Check field types
for doc in all_docs {
    if let Some(age) = doc.data().get("age") {
        println!("Age type: {:?}", age);
    }
}
```

### Slow Query Performance

**Problem:** Queries take too long to execute.

**Causes:**

- Large collection (many documents)
- Complex filters
- Missing field projection
- Not using streaming

**Solutions:**

```rust
// Use streaming instead of collecting all
let query = QueryBuilder::new()
    .filter("status", Operator::Equals, json!("active"))
    .build();

let result = users.query(query).await?;
let mut stream = result.documents;

// Process one at a time
while let Some(doc) = stream.try_next().await? {
    // Process document without loading all into memory
    process_document(doc).await?;
}

// Use field projection to reduce data transfer
let query = QueryBuilder::new()
    .filter("role", Operator::Equals, json!("admin"))
    .project(vec!["name".to_string(), "email".to_string()])
    .build();

// Use limit for pagination
let query = QueryBuilder::new()
    .limit(100)
    .build();
```

### Passphrase Issues

**Problem:** Cannot open store created with passphrase.

**Causes:**

- Wrong passphrase
- Signing key file corrupted
- Crypto config mismatch

**Solutions:**

```rust
// Try to open store
match Store::new("./my_store", Some("my-passphrase")).await {
    Ok(store) => println!("Store opened successfully"),
    Err(e) => {
        eprintln!("Failed to open store: {}", e);
        // Check if signing key file exists
        if std::path::Path::new("./my_store/data/.keys/signing_key.json").exists() {
            println!("Signing key file exists - passphrase may be incorrect");
        } else {
            println!("No signing key file found");
        }
    }
}

// Create store without passphrase if needed
let store = Store::new("./my_store", None).await?;
```

### Crypto Configuration Errors

**Problem:** `CryptoError` when performing operations.

**Causes:**

- Global config not set
- Config set multiple times
- Incompatible algorithm choices

**Solutions:**

```rust
use sentinel_dbms::{CryptoConfig, set_global_crypto_config};

// Set config once at application startup
#[tokio::main]
async fn main() {
    let config = CryptoConfig {
        hash_algorithm: HashAlgorithmChoice::Blake3,
        signature_algorithm: SignatureAlgorithmChoice::Ed25519,
        encryption_algorithm: EncryptionAlgorithmChoice::XChaCha20Poly1305,
        key_derivation_algorithm: KeyDerivationAlgorithmChoice::Argon2id,
    };

    // Only call once
    if let Err(e) = set_global_crypto_config(config).await {
        eprintln!("Config already set: {}", e);
    }
}
```

## Write-Ahead Logging (WAL) Issues

### WAL Operations Failing

**Problem:** Operations fail with "WAL write failed" error.

**Causes:**

- Disk full or out of space
- Permission issues in `.wal/` directory
- WAL configured in Strict mode
- Filesystem corruption

**Solutions:**

```rust
use sentinel_dbms::wal::ops::CollectionWalOps;
use sentinel_wal::{WalFailureMode, CollectionWalConfig};

// Check available disk space
let available = check_disk_space("./data")?;
if available < 100 * 1024 * 1024 {  // 100MB
    eprintln!("Warning: Less than 100MB disk space");
}

// Note: WAL configuration cannot be changed at runtime.
// To use Warn mode, recreate the collection with different config:
let mut new_config = CollectionWalConfig::default();
new_config.write_mode = WalFailureMode::Warn;
let new_collection = store.collection_with_config("collection_name", Some(new_config)).await?;

// Monitor WAL size
let wal_size = collection.wal_size().await?;
println!("WAL size: {} bytes", wal_size);

// Checkpoint to reclaim space
if wal_size > 100 * 1024 * 1024 {
    collection.checkpoint_wal().await?;
}
```

### WAL File Grows Too Large

**Problem:** WAL file continuously grows, consuming disk space.

**Causes:**

- Checkpoints not being called
- No rotation configured
- High write volume without maintenance

**Solutions:**

```rust
use sentinel_wal::CollectionWalConfig;
use sentinel_dbms::wal::ops::CollectionWalOps;

// 1. Set reasonable rotation limits
let mut config = CollectionWalConfig::default();
config.max_wal_size_bytes = Some(50 * 1024 * 1024);  // 50MB
config.max_records_per_file = Some(5000);

// 2. Schedule regular checkpoints
use std::time::Duration;
use tokio::time::interval;

tokio::spawn({
    let collection = collection.clone();
    async move {
        let mut ticker = interval(Duration::from_secs(3600));
        loop {
            ticker.tick().await;
            match collection.checkpoint_wal().await {
                Ok(_) => println!("Checkpoint completed"),
                Err(e) => eprintln!("Checkpoint failed: {}", e),
            }
        }
    }
});

// 3. Monitor WAL size
let wal_size = collection.wal_size().await?;
if wal_size > 100 * 1024 * 1024 {
    eprintln!("WAL exceeds 100MB, consider checkpointing");
}
```

### Verification Fails

**Problem:** `verify_wal()` returns issues or fails completely.

**Causes:**

- WAL corruption
- Incomplete operations (crash during write)
- Mismatch between WAL and disk state
- Filesystem inconsistency

**Solutions:**

```rust
use sentinel_dbms::wal::ops::CollectionWalOps;

// 1. Check verification result
let result = collection.verify_wal().await?;

if !result.passed {
    println!("Verification found {} issues", result.issues.len());

    for issue in &result.issues {
        if issue.is_critical {
            eprintln!("CRITICAL: {}", issue.description);
        } else {
            println!("WARNING: {}", issue.description);
        }
    }
}

// 2. Recover from WAL
println!("Attempting recovery...");
let recovery = collection.recover_from_wal().await?;
println!("Recovered: {}", recovery.recovered_operations);

// 3. Verify again after recovery
let re_verify = collection.verify_wal().await?;
if re_verify.passed {
    println!("✓ Collection is consistent");
} else {
    eprintln!("✗ Issues persist after recovery");
    // Consider restore from backup
}
```

### Recovery Loses Data

**Problem:** After recovery, some documents are missing.

**Causes:**

- WAL was not synced before crash
- Checkpoint deleted WAL but documents weren't written to disk
- Soft deletes being treated as hard deletes
- Configuration issue with recovery mode

**Solutions:**

```rust
use sentinel_dbms::wal::ops::CollectionWalOps;
use sentinel_wal::{CollectionWalConfig, WalFailureMode};

// Ensure recovery is enabled with Strict mode
let mut config = CollectionWalConfig::default();
config.enable_recovery = true;
config.write_mode = WalFailureMode::Strict;

// Monitor recovery results
let result = collection.recover_from_wal().await?;
println!("Recovered: {}", result.recovered_operations);
println!("Skipped: {} (already applied)", result.skipped_operations);

if result.failed_operations > 0 {
    eprintln!("Failed: {} operations", result.failed_operations);
    for failure in &result.failures {
        eprintln!("  {} - {}", failure.document_id, failure.reason);
    }
}
```

### WAL Format Issues

**Problem:** WAL file is corrupted or unreadable.

**Causes:**

- Wrong format configured
- File truncation
- Filesystem corruption
- Version mismatch

**Solutions:**

```rust
use sentinel_wal::{CollectionWalConfig, WalFormat};
use sentinel_dbms::wal::ops::CollectionWalOps;
use futures::StreamExt;

// 1. Check current format
let config = collection.wal_config();
println!("WAL format: {:?}", config.format);

// 2. Try to read WAL entries
match collection.stream_wal_entries().await {
    Ok(mut stream) => {
        let mut entry_count = 0;
        while let Some(result) = stream.next().await {
            match result {
                Ok(_entry) => entry_count += 1,
                Err(e) => {
                    eprintln!("Error reading entry {}: {}", entry_count, e);
                    break;
                }
            }
        }
        println!("Successfully read {} entries", entry_count);
    },
    Err(e) => eprintln!("Failed to read WAL: {}", e),
}

// 3. Note: WAL format cannot be changed at runtime.
// To use JSON format, recreate the collection with different config:
let mut new_config = CollectionWalConfig::default();
new_config.format = WalFormat::JsonLines;
let new_collection = store.collection_with_config("collection_name", Some(new_config)).await?;
```

### General Questions

**Q: Is Sentinel production-ready?**

A: Sentinel is in active development. Current version (0.1.x) is suitable for:

- Audit logging systems
- Configuration management
- Certificate storage
- Development and testing
- Low-to-medium write workloads

Not recommended yet for:

- High-frequency trading systems
- Real-time bidding platforms
- Applications requiring millions of writes per second

**Q: How does Sentinel compare to PostgreSQL/MongoDB?**

A: Sentinel prioritizes different goals:

| Feature      | PostgreSQL/MongoDB  | Sentinel            |
| ------------ | ------------------- | ------------------- |
| Query Speed  | Faster (indexed)    | Slower (in-memory)  |
| Setup        | Complex             | Simple (no server)  |
| Auditability | Requires logging    | Built-in            |
| Transparency | Binary formats      | Plain JSON          |
| Tools        | Custom clients      | Standard Unix tools |
| Scaling      | Vertical/Horizontal | Filesystem limits   |

**Q: Can I use Sentinel for my project?**

A: Good fit if you need:

- ✓ Auditability and compliance
- ✓ Human-readable data
- ✓ Simple deployment
- ✓ Git versioning
- ✓ Filesystem-level security
- ✓ Crash recovery (with WAL)

Not a good fit if you need:

- ✗ Complex joins
- ✗ High-frequency writes
- ✗ Real-time analytics
- ✗ Distributed transactions

### Write-Ahead Logging (WAL)

**Q: Do I need to use WAL?**

A: WAL is optional but recommended for:

- **Critical data** (audit logs, financial records)
- **Compliance** (GDPR, SOC 2, HIPAA)
- **Crash recovery** (systems that may crash)

You can disable WAL for:

- **Temporary data** (caches, sessions)
- **Non-critical data** (metrics, analytics)
- **High-throughput systems** (where performance > durability)

**Q: How much disk space does WAL use?**

A: WAL adds overhead:

- **Binary format**: ~5-20% of document size per entry
- **JSON format**: ~30-50% of document size per entry
- **Compressed**: 50-80% reduction for rotated files

You control this with rotation:

```rust
config.max_wal_size_bytes = Some(50 * 1024 * 1024);  // 50MB max
config.max_records_per_file = Some(5000);
collection.checkpoint_wal().await?;  // Reclaim space
```

**Q: Will WAL slow down my application?**

A: Performance impact depends on configuration:

- **Strict mode**: 5-10% slower (ensures durability)
- **Warn mode**: 1-2% slower (best effort)
- **Disabled**: No overhead (no crash recovery)

For high-throughput, use Warn mode or batch operations before checkpointing.

**Q: What happens if a crash occurs?**

A: WAL prevents data loss:

```
Before crash: Insert operation logged to WAL ✓
             Insert operation to disk: In progress...
             CRASH! ✗

After restart: Load collection
              Detect incomplete operation in WAL
              Replay operation to disk
              ✓ Data recovered
```

**Q: How do I test that recovery works?**

A: Use temporary directories and verify:

```rust
#[tokio::test]
async fn test_wal_recovery() {
    let temp = tempfile::tempdir().unwrap();
    let store = Store::new(temp.path(), None).await.unwrap();
    let col = store.collection("test").await.unwrap();

    col.insert("doc-1", json!({"value": 1})).await.unwrap();
    // Intentionally not checkpointing

    // Simulate restart
    drop(col);

    let store2 = Store::new(temp.path(), None).await.unwrap();
    let col2 = store2.collection("test").await.unwrap();
    let result = col2.recover_from_wal().await.unwrap();

    assert!(result.recovered_operations > 0);
}
```

### Data & Storage

**Q: What's the maximum collection size?**

A: Practical limits:

- **Documents**: Unlimited (filesystem dependent)
- **Performance**: Starts degrading around 100,000 documents per collection
- **Recommendation**: Use multiple collections or sharding for larger datasets

**Q: Are documents really just JSON files?**

A: Yes! You can:

```bash
# View documents
cat ./data/users/alice.json

# Edit documents (careful!)
vim ./data/users/alice.json

# Search documents
grep -r "admin" ./data/users/

# Backup
tar -czf backup.tar.gz ./data/
```

**Q: What happens to deleted documents?**

A: Sentinel uses soft deletes:

- Documents moved to `.deleted/` subdirectory
- Original filename preserved
- Can be recovered manually
- Maintains audit trail

```bash
# View deleted documents
ls -la ./data/users/.deleted/

# Restore deleted document
mv ./data/users/.deleted/alice.json ./data/users/alice.json
```

**Q: Can I encrypt data at rest?**

A: Yes, in two ways:

1. **Document Signing** (tamper detection):

```rust
let store = Store::new("./data", Some("passphrase")).await?;
```

2. **Field Encryption** (data protection):

```rust
use sentinel_dbms::encrypt_data;

let encrypted = encrypt_data(b"sensitive", &key).await?;
users.insert("doc-1", json!({
    "name": "Alice",
    "ssn": encrypted  // Encrypted field
})).await?;
```

### Querying

**Q: Why are queries slow?**

A: Current implementation:

- No indices (yet) - scans all documents
- In-memory filtering
- File I/O for each document

**Future improvements:**

- Lazy-built indices for common queries
- Hash indices for equality lookups
- Range indices for comparisons

**Q: Can I do full-text search?**

A: Not yet. Planned for future release. Current workaround:

```rust
// Use Contains operator for substring search
let query = QueryBuilder::new()
    .filter("content", Operator::Contains, json!("search term"))
    .build();
```

**Q: How do I do OR queries?**

A: Use predicate-based filtering:

```rust
let results = users.filter(|doc| {
    let role = doc.data().get("role").and_then(|v| v.as_str());
    role == Some("admin") || role == Some("moderator")
});
```

### Performance

**Q: How fast is Sentinel?**

A: Approximate performance (depends on hardware):

| Operation | Speed    | Notes            |
| --------- | -------- | ---------------- |
| Insert    | 1-5ms    | Single document  |
| Get       | 0.5-2ms  | By ID            |
| Update    | 1-5ms    | Single document  |
| Delete    | 0.5-1ms  | Rename operation |
| Query     | 100ms-1s | For 10,000 docs  |

**Q: How can I improve performance?**

A: Best practices:

1. Use streaming for large result sets
2. Apply field projection to reduce data transfer
3. Use meaningful document IDs for direct access
4. Implement application-level caching
5. Batch operations when possible
6. Use limit/offset for pagination

### Concurrency

**Q: Can multiple processes access the same store?**

A: Current limitations:

- **Reads**: Safe from multiple processes
- **Writes**: Last-write-wins, potential data loss
- **Future**: File locking and WAL for safe concurrent writes

**Q: Is Sentinel thread-safe?**

A: Yes, within a single process:

```rust
let store = Arc::new(store);

// Safe to share across threads
let store1 = store.clone();
tokio::spawn(async move {
    let users = store1.collection("users").await?;
    // Use collection
});
```

### Security

**Q: How secure is Sentinel?**

A: Security features:

- **Hashing**: BLAKE3 (256-bit security)
- **Signing**: Ed25519 (128-bit security level)
- **Encryption**: XChaCha20-Poly1305, AES-256-GCM-SIV, or Ascon-128
- **Key Derivation**: Argon2id or PBKDF2

**Q: Are signatures mandatory?**

A: No. Signatures are optional:

```rust
// Without signing
let store = Store::new("./data", None).await?;

// With signing
let store = Store::new("./data", Some("passphrase")).await?;
```

**Q: How do I verify document integrity?**

A: Check the hash:

```rust
use sentinel_dbms::hash_data;

let doc = users.get("alice").await?.unwrap();
let computed_hash = hash_data(doc.data()).await?;

if computed_hash == doc.hash() {
    println!("✓ Document is intact");
} else {
    println!("✗ Document has been modified");
}
```

### Deployment

**Q: Do I need to install a database server?**

A: No! Sentinel is:

- Embedded in your application
- No separate server process
- No network configuration
- Just a directory on disk

**Q: How do I backup Sentinel?**

A: Use standard tools:

```bash
# Tar backup
tar -czf sentinel-backup.tar.gz ./data/

# Rsync to remote server
rsync -avz ./data/ user@backup-server:/backups/sentinel/

# Git (for version control)
cd ./data
git init
git add .
git commit -m "Backup"
git push origin main
```

**Q: Can I use Sentinel in Docker?**

A: Yes:

```dockerfile
FROM rust:latest
WORKDIR /app
COPY . .
RUN cargo build --release

# Mount volume for persistent storage
VOLUME /app/data
CMD ["./target/release/myapp"]
```

### Development

**Q: How do I test with Sentinel?**

A: Use temporary directories:

```rust
#[tokio::test]
async fn test_sentinel() -> Result<()> {
    use tempfile::TempDir;

    let temp = TempDir::new()?;
    let store = Store::new(temp.path(), None).await?;

    // Run tests

    // Cleanup happens automatically
    Ok(())
}
```

**Q: Can I contribute to Sentinel?**

A: Yes! We welcome contributions:

1. Check [GitHub Issues](https://github.com/cyberpath-HQ/sentinel/issues)
2. Read [CONTRIBUTING.md](https://github.com/cyberpath-HQ/sentinel/blob/main/CONTRIBUTING.md)
3. Join [Discussions](https://github.com/cyberpath-HQ/sentinel/discussions)

## Debugging Tips

### Enable Verbose Logging

```rust
// In your application
use tracing_subscriber;

tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();
```

### Inspect Store Structure

```bash
# List all collections
ls -la ./data/

# Count documents in collection
find ./data/users -name "*.json" -not -path "*/.*" | wc -l

# Check deleted documents
ls -la ./data/users/.deleted/

# View document
cat ./data/users/alice.json | jq .
```

### Monitor File Operations

```bash
# On Linux
strace -e trace=file ./my_app

# On macOS
dtruss -f ./my_app
```

### Profile Performance

```rust
use std::time::Instant;

let start = Instant::now();
let result = users.query(query).await?;
println!("Query took: {:?}", start.elapsed());
```

## Getting Help

If you're still stuck:

1. **Search Issues**: [GitHub Issues](https://github.com/cyberpath-HQ/sentinel/issues)
2. **Ask Questions**: [GitHub Discussions](https://github.com/cyberpath-HQ/sentinel/discussions)
3. **Report Bugs**: [New Issue](https://github.com/cyberpath-HQ/sentinel/issues/new)
4. **Read Docs**: Check [documentation](https://sentinel.cyberpath-hq.com)

## Next Steps

- Review [Examples](/docs/examples) for common patterns
- Understand [Architecture](/docs/architecture) for deeper knowledge
- Explore [API Reference](/docs/api-reference) for complete API
- Check [Migration Guide](/docs/migration-guide) for transitions
